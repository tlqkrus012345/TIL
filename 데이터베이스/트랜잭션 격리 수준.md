여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것입니다.

격리 수준은 크게 ‘read uncommitted’ , ‘read committed’, repeatable read’, ‘serializable’ 4가지로 나누어집니다.
일반적인 데이터베이스에 사용하지 않는 read uncommitted는 각 트랜잭션에서의 변경 내용이 commit이나 rollback 여부와 상관없이 다른 트랜잭션에서 보이는 dirty read가 발생한다는 특징이 있습니다.

read committed은 어떤 트랜잭션에서 데이터를 변경했더라도 commit이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있습니다. dirty read는 발생하지 않지만 하나의 트랜잭션에서 동일한 쿼리에 대한 같은 결과를 가져오지 않아 repeatable read 정합성을 위반하고 있습니다.

repeatable read는 mysql innodb 스토리엔진에서 기본적으로 사용하는 격리 수준입니다. 언두영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장합니다.
read committed도 언두 영역에 백업된 레코드를 보여주지만 두 격리 수준의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있습니다. 언두 영역에는 트랜잭션 번호도 저장하는데 이때 저장된 트랜잭션 번호와 현재 시작한 트랜잭션 번호를 비교하여 자신보다 낮은 트랜잭션 번호만 언두 영역에서 가져오기 때문에 repeatable read 정합성을 보장할 수 있습니다. 여기서 언두 영역이 백업된 데이터로 무한정 커 질 수 있다는 문제점이 있어 트랜잭션 종료가 중요합니다.
마지막으로 repeatable read에서는 데이터 부정합이 발생할 수 있습니다. select … for update 쿼리를 실행했을 때 다른 트랜잭션에서 인서트한 결과를 볼 수 있는 phantom read 현상이 발생할 수 있습니다. 그 이유는 언두 레코드에는 잠금을 걸 수 없기 떄문에 공유락 베타락을 걸 경우에는 언두 영역의 변경 전 데이터를 가져오는 것이 아닌 현재 레코드 값을 가져오게 됩니다. 하지만 innodb에서는 갭 락과 넥스트 키 락 덕분에 발생하지 않습니다.

동시성이 중요한 데이터베이스에서는 사용하지 않는 serializable는 잠금이 필요없는 일관된 읽기 쿼리에서는 공유 잠금을 획득하는 격리 수준입니다.

* innodb 스토리엔진은 rollback 가능성을 염두하여 undo 공간에 백업하고 실제 레코드를 변경합니다 이러한 방식을 mvcc라 합니다.
